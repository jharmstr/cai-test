[{"name": "app.py", "content": "# app.py\n# Run: shiny run --reload app.py\n# Requires: pip install shiny biopython pandas matplotlib seaborn\n\n\nfrom __future__ import annotations\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nfrom Bio import SeqIO\nfrom collections import defaultdict, Counter\nimport math\nimport pandas as pd\nimport io\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport re\nfrom typing import Dict, List, Tuple\n\n# ---------------- Built-in weights ----------------\nECOLI_CAI = {\n    'TTT': 0.58, 'TTC': 1.00, 'TTA': 0.02, 'TTG': 0.07,\n    'CTT': 0.13, 'CTC': 0.20, 'CTA': 0.02, 'CTG': 1.00,\n    'ATT': 0.49, 'ATC': 1.00, 'ATA': 0.03, 'ATG': 1.00,\n    'GTT': 0.35, 'GTC': 0.47, 'GTA': 0.07, 'GTG': 1.00,\n    'TCT': 0.22, 'TCC': 0.39, 'TCA': 0.15, 'TCG': 0.06,\n    'AGT': 0.15, 'AGC': 1.00,\n    'CCT': 0.42, 'CCC': 0.29, 'CCA': 0.28, 'CCG': 1.00,\n    'ACT': 0.23, 'ACC': 1.00, 'ACA': 0.36, 'ACG': 0.47,\n    'GCT': 0.37, 'GCC': 1.00, 'GCA': 0.28, 'GCG': 0.76,\n    'TAT': 0.43, 'TAC': 1.00, 'CAT': 0.43, 'CAC': 1.00,\n    'CAA': 0.27, 'CAG': 1.00, 'AAT': 0.47, 'AAC': 1.00,\n    'AAA': 0.44, 'AAG': 1.00, 'GAT': 0.63, 'GAC': 1.00,\n    'GAA': 0.68, 'GAG': 1.00, 'TGT': 0.44, 'TGC': 1.00,\n    'TGG': 1.00,\n    'CGT': 0.36, 'CGC': 1.00, 'CGA': 0.07, 'CGG': 0.11,\n    'AGA': 0.02, 'AGG': 0.02,\n    'GGT': 0.41, 'GGC': 1.00, 'GGA': 0.25, 'GGG': 0.50\n}\nECOLI_TAI = {\n    'TTT': 0.43, 'TTC': 1.00, 'TTA': 0.17, 'TTG': 0.32,\n    'CTT': 0.22, 'CTC': 0.38, 'CTA': 0.07, 'CTG': 1.00,\n    'ATT': 0.38, 'ATC': 0.69, 'ATA': 0.10, 'ATG': 1.00,\n    'GTT': 0.31, 'GTC': 0.44, 'GTA': 0.09, 'GTG': 1.00,\n    'TCT': 0.32, 'TCC': 0.51, 'TCA': 0.27, 'TCG': 0.23,\n    'AGT': 0.25, 'AGC': 0.55,\n    'CCT': 0.31, 'CCC': 0.29, 'CCA': 0.25, 'CCG': 1.00,\n    'ACT': 0.28, 'ACC': 1.00, 'ACA': 0.38, 'ACG': 0.47,\n    'GCT': 0.37, 'GCC': 1.00, 'GCA': 0.29, 'GCG': 0.69,\n    'TAT': 0.37, 'TAC': 1.00, 'CAT': 0.41, 'CAC': 1.00,\n    'CAA': 0.36, 'CAG': 1.00, 'AAT': 0.48, 'AAC': 1.00,\n    'AAA': 0.38, 'AAG': 1.00, 'GAT': 0.54, 'GAC': 1.00,\n    'GAA': 0.59, 'GAG': 1.00, 'TGT': 0.45, 'TGC': 1.00,\n    'TGG': 1.00,\n    'CGT': 0.27, 'CGC': 1.00, 'CGA': 0.09, 'CGG': 0.13,\n    'AGA': 0.05, 'AGG': 0.05,\n    'GGT': 0.39, 'GGC': 1.00, 'GGA': 0.21, 'GGG': 0.47\n}\n\n# Codon table for ENC\nCODON_TABLE: Dict[str, List[str]] = {\n    'F': ['TTT', 'TTC'], 'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'],\n    'I': ['ATT', 'ATC', 'ATA'], 'M': ['ATG'], 'V': ['GTT', 'GTC', 'GTA', 'GTG'],\n    'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'], 'P': ['CCT', 'CCC', 'CCA', 'CCG'],\n    'T': ['ACT', 'ACC', 'ACA', 'ACG'], 'A': ['GCT', 'GCC', 'GCA', 'GCG'],\n    'Y': ['TAT', 'TAC'], 'H': ['CAT', 'CAC'], 'Q': ['CAA', 'CAG'],\n    'N': ['AAT', 'AAC'], 'K': ['AAA', 'AAG'], 'D': ['GAT', 'GAC'],\n    'E': ['GAA', 'GAG'], 'C': ['TGT', 'TGC'], 'W': ['TGG'],\n    'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'], 'G': ['GGT', 'GGC', 'GGA', 'GGG']\n}\nSENSE_CODONS: List[str] = sorted({c for codons in CODON_TABLE.values() for c in codons})\n\n# ---------------- Calculators ----------------\ndef normalize_seq(seq: str) -> str:\n    s = seq.upper().replace(\" \", \"\").replace(\"\\n\", \"\").replace(\"U\", \"T\")\n    return re.sub(r\"[^ACGT]\", \"\", s)\n\ndef calculate_index(seq: str, weights: Dict[str, float]) -> float:\n    seq = normalize_seq(seq)\n    log_sum, count = 0.0, 0\n    for i in range(0, len(seq) - 2, 3):\n        codon = seq[i:i+3]\n        w = weights.get(codon, 0.0)\n        if w > 0.0:\n            log_sum += math.log(w)\n            count += 1\n    return math.exp(log_sum / count) if count else 0.0\n\ndef calculate_cai(seq: str, cai_weights: Dict[str, float]) -> float:\n    return calculate_index(seq, cai_weights)\n\ndef calculate_tai(seq: str, tai_weights: Dict[str, float]) -> float:\n    return calculate_index(seq, tai_weights)\n\ndef calculate_enc(seq: str) -> float:\n    seq = normalize_seq(seq)\n    aa_codon_counts: Dict[str, Counter[str]] = defaultdict(Counter)\n    for i in range(0, len(seq) - 2, 3):\n        codon = seq[i:i+3]\n        for aa, codons in CODON_TABLE.items():\n            if codon in codons:\n                aa_codon_counts[aa][codon] += 1\n\n    Fk_list: List[Tuple[int, float]] = []\n    for codons in aa_codon_counts.values():\n        k = len(codons)\n        if k <= 1:\n            continue\n        n = sum(codons.values())\n        fk = sum((c / n) ** 2 for c in codons.values())\n        if n > 1:\n            Fk = (n * fk - 1) / (n - 1)\n            if Fk > 0:\n                Fk_list.append((k, Fk))\n\n    if not Fk_list:\n        return 61.0\n    try:\n        return float(2 + sum(k for k, _ in Fk_list) / sum(1 / Fk for _, Fk in Fk_list))\n    except ZeroDivisionError:\n        return 61.0\n\ndef compute_codon_metrics_from_fasta(fasta_path: str, cai_w: Dict[str, float], tai_w: Dict[str, float]) -> pd.DataFrame:\n    results = []\n    for record in SeqIO.parse(fasta_path, \"fasta\"):\n        seq = str(record.seq)\n        results.append({\n            \"ID\": record.id,\n            \"CAI\": round(calculate_cai(seq, cai_w), 4),\n            \"tAI\": round(calculate_tai(seq, tai_w), 4),\n            \"ENC\": round(calculate_enc(seq), 2),\n        })\n    return pd.DataFrame(results)\n\ndef parse_sequences_from_text(text: str) -> List[Tuple[str, str]]:\n    \"\"\"Accepts FASTA text or newline-delimited raw sequences. Returns [(ID, seq)].\"\"\"\n    text = text.strip()\n    if not text:\n        return []\n    if text.startswith(\">\"):\n        entries = []\n        sid, buf = None, []\n        for line in text.splitlines():\n            if line.startswith(\">\"):\n                if sid is not None and buf:\n                    entries.append((sid, \"\".join(buf)))\n                sid = line[1:].strip() or f\"seq{len(entries)+1}\"\n                buf = []\n            else:\n                buf.append(line.strip())\n        if sid is not None:\n            entries.append((sid, \"\".join(buf)))\n        return [(sid, normalize_seq(seq)) for sid, seq in entries if normalize_seq(seq)]\n    else:\n        seqs = [normalize_seq(l) for l in text.splitlines() if l.strip()]\n        return [(f\"seq{i+1}\", s) for i, s in enumerate(seqs) if s]\n\ndef compute_codon_metrics_from_text(text: str, cai_w: Dict[str, float], tai_w: Dict[str, float]) -> pd.DataFrame:\n    seqs = parse_sequences_from_text(text)\n    results = []\n    for sid, seq in seqs:\n        results.append({\n            \"ID\": sid,\n            \"CAI\": round(calculate_cai(seq, cai_w), 4),\n            \"tAI\": round(calculate_tai(seq, tai_w), 4),\n            \"ENC\": round(calculate_enc(seq), 2),\n        })\n    return pd.DataFrame(results)\n\ndef read_weights_csv(fileinfo: List[FileInfo] | None) -> Dict[str, float] | None:\n    if not fileinfo:\n        return None\n    path = fileinfo[0][\"datapath\"]\n    df = pd.read_csv(path)\n    cols = {c.lower(): c for c in df.columns}\n    if \"codon\" not in cols or \"weight\" not in cols:\n        raise ValueError(\"Weights CSV must have columns: codon, weight\")\n    df = df.rename(columns={cols[\"codon\"]: \"codon\", cols[\"weight\"]: \"weight\"})\n    df[\"codon\"] = df[\"codon\"].str.upper().str.replace(\"U\", \"T\")\n    sub = df[df[\"codon\"].isin(SENSE_CODONS)][[\"codon\", \"weight\"]].dropna()\n    return dict(zip(sub[\"codon\"], sub[\"weight\"]))\n\ndef pick_weights(species: str, cai_up: Dict[str, float] | None, tai_up: Dict[str, float] | None) -> Tuple[Dict[str, float], Dict[str, float]]:\n    if species == \"ecoli\":\n        return ECOLI_CAI, ECOLI_TAI\n    if cai_up is None or tai_up is None:\n        eq = {c: 1.0 for c in SENSE_CODONS}\n        return eq, eq\n    return cai_up, tai_up\n\ndef make_boxplot_figure(df: pd.DataFrame, combined: bool = False):\n    if df.empty or (\"Error\" in df.columns):\n        fig = plt.figure(figsize=(4, 2))\n        plt.text(0.5, 0.5, \"Provide valid sequences to see results\", ha=\"center\", va=\"center\")\n        plt.axis(\"off\")\n        return fig\n    if combined:\n        df_m = df.melt(id_vars=[\"ID\"], value_vars=[\"CAI\", \"tAI\", \"ENC\"],\n                       var_name=\"Metric\", value_name=\"Value\")\n        plt.figure(figsize=(6, 4))\n        sns.boxplot(x=\"Metric\", y=\"Value\", data=df_m)\n        plt.ylabel(\"Value\")\n        plt.title(\"Codon Usage Metrics\")\n        plt.tight_layout()\n        return plt.gcf()\n    fig, axes = plt.subplots(1, 3, figsize=(12, 4))\n    sns.boxplot(y=df[\"CAI\"], ax=axes[0], width=0.3); axes[0].set_title(\"CAI\"); axes[0].set_ylabel(\"CAI\"); axes[0].set_xticks([])\n    sns.boxplot(y=df[\"tAI\"], ax=axes[1], width=0.3); axes[1].set_title(\"tAI\"); axes[1].set_ylabel(\"tAI\"); axes[1].set_xticks([])\n    sns.boxplot(y=df[\"ENC\"], ax=axes[2], width=0.3); axes[2].set_title(\"ENC\"); axes[2].set_ylabel(\"ENC\"); axes[2].set_xticks([])\n    plt.tight_layout()\n    return fig\n\n# ---------------- UI ----------------\napp_ui = ui.page_fillable(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_radio_buttons(\n                \"input_mode\", \"Input method\",\n                choices={\"upload\": \"Upload FASTA\", \"paste\": \"Paste sequences\"},\n                selected=\"upload\"\n            ),\n            ui.panel_conditional(\n                \"input.input_mode == 'upload'\",\n                ui.input_file(\"fasta\", \"Upload FASTA\", accept=[\".fa\", \".fasta\", \".fna\"])\n            ),\n            ui.panel_conditional(\n                \"input.input_mode == 'paste'\",\n                ui.input_text_area(\n                    \"seq_text\", \"Paste sequences\",\n                    placeholder=\"FASTA format preferred (e.g., >id1\\nATGGCC...)\\nOr one DNA/RNA sequence per line.\",\n                    rows=10\n                )\n            ),\n            ui.hr(),\n            ui.input_radio_buttons(\n                \"species\", \"Weights\",\n                choices={\"ecoli\": \"E. coli K-12 (built-in)\", \"custom\": \"Custom (upload CSVs)\"},\n                selected=\"ecoli\"\n            ),\n            ui.panel_conditional(\n                \"input.species == 'custom'\",\n                ui.help_text(\"CSV must have columns: codon, weight; codons like TTT (DNA).\"),\n                ui.input_file(\"cai_csv\", \"Upload CAI weights (CSV)\", accept=[\".csv\"]),\n                ui.input_file(\"tai_csv\", \"Upload tAI weights (CSV)\", accept=[\".csv\"]),\n                ui.help_text(\"If either file is missing, equal weights (1.0) will be used.\")\n            ),\n            ui.input_switch(\"combined\", \"Combine plots into one\", value=False),\n            ui.hr(),\n            ui.download_button(\"download_csv\", \"Download metrics (CSV)\"),\n            ui.download_button(\"download_plot\", \"Download plot (PNG)\"),\n            width=320\n        ),\n        ui.layout_columns(\n            ui.card(\n                ui.card_header(\"Codon Metrics Table\"),\n                ui.output_data_frame(\"metrics_df\")\n            ),\n            ui.card(\n                ui.card_header(\"Copy-paste table (TSV)\"),\n                ui.output_ui(\"metrics_tsv_ui\")\n            ),\n        ),\n        ui.card(\n            ui.card_header(\"CAI / tAI / ENC Boxplots\"),\n            ui.output_plot(\"metrics_plot\", height=\"420px\")\n        ),\n    ),\n    title=\"Codon Metrics (CAI, tAI, ENC)\"\n)\n\n# ---------------- Server ----------------\ndef server(input: Inputs, output: Outputs, session: Session):\n\n    # Load custom weight CSVs (reactive)\n    @reactive.calc\n    def custom_cai():\n        try:\n            return read_weights_csv(input.cai_csv())\n        except Exception as e:\n            return {\"__error__\": str(e)}\n\n    @reactive.calc\n    def custom_tai():\n        try:\n            return read_weights_csv(input.tai_csv())\n        except Exception as e:\n            return {\"__error__\": str(e)}\n\n    @reactive.calc\n    def active_weights() -> Tuple[Dict[str, float], Dict[str, float]]:\n        species = input.species()\n        cai_w = custom_cai()\n        tai_w = custom_tai()\n        if isinstance(cai_w, dict) and \"__error__\" in cai_w:\n            cai_w = None\n        if isinstance(tai_w, dict) and \"__error__\" in tai_w:\n            tai_w = None\n        return pick_weights(species, cai_w, tai_w)\n\n    # Central metrics DF (reactive)\n    @reactive.calc\n    def metrics_df_calc() -> pd.DataFrame:\n        cai_w, tai_w = active_weights()\n        mode = input.input_mode()\n        try:\n            if mode == \"upload\":\n                files = input.fasta()\n                if not files:\n                    return pd.DataFrame(columns=[\"ID\", \"CAI\", \"tAI\", \"ENC\"])\n                path = files[0][\"datapath\"]\n                df = compute_codon_metrics_from_fasta(path, cai_w, tai_w)\n            else:\n                text = input.seq_text() or \"\"\n                df = compute_codon_metrics_from_text(text, cai_w, tai_w)\n            if not df.empty:\n                df = df[[\"ID\", \"CAI\", \"tAI\", \"ENC\"]]\n            return df\n        except Exception as e:\n            # Show the error in-table instead of spinning forever\n            return pd.DataFrame({\"Error\": [str(e)]})\n\n    # Interactive table (id matches function name)\n    @render.data_frame\n    def metrics_df():\n        df = metrics_df_calc()\n        return render.DataTable(df)\n\n    # Copy-paste TSV UI (readonly textarea + copy button)\n    @render.ui\n    def metrics_tsv_ui():\n        df = metrics_df_calc()\n        if df.empty:\n            tsv = \"ID\\tCAI\\ttAI\\tENC\"\n        elif \"Error\" in df.columns:\n            tsv = df.to_csv(sep=\"\\t\", index=False, lineterminator=\"\\n\")\n        else:\n            tsv = df.to_csv(sep=\"\\t\", index=False, lineterminator=\"\\n\")\n        return ui.TagList(\n            ui.input_action_button(\"copy_btn\", \"Copy to clipboard\"),\n            ui.tags.textarea(\n                tsv,\n                id=\"tsv_area\",\n                readonly=True,\n                style=(\n                    \"width:100%; height:240px; \"\n                    \"font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"\n                    \"'Liberation Mono', 'Courier New', monospace;\"\n                ),\n            ),\n            ui.tags.script(\n                \"\"\"\n                (function(){\n                  const btn = document.getElementById(\"copy_btn\");\n                  const ta  = document.getElementById(\"tsv_area\");\n                  if (!btn || !ta) return;\n                  btn.onclick = async function(){\n                    ta.focus();\n                    ta.select();\n                    ta.setSelectionRange(0, ta.value.length);\n                    try { await navigator.clipboard.writeText(ta.value); }\n                    catch (e) { document.execCommand(\"copy\"); }\n                  };\n                })();\n                \"\"\"\n            )\n        )\n\n    # Plot\n    @render.plot(alt=\"Boxplots of CAI, tAI, and ENC\")\n    def metrics_plot():\n        df = metrics_df_calc()\n        return make_boxplot_figure(df, combined=bool(input.combined()))\n\n    # Downloads\n    @render.download(filename=\"codon_metrics.csv\")\n    def download_csv():\n        df = metrics_df_calc()\n        with io.StringIO() as s:\n            df.to_csv(s, index=False)\n            yield s.getvalue()\n\n    @render.download(filename=\"codon_metrics_boxplot.png\")\n    def download_plot():\n        df = metrics_df_calc()\n        fig = make_boxplot_figure(df, combined=bool(input.combined()))\n        with io.BytesIO() as buf:\n            fig.savefig(buf, format=\"png\", dpi=300, bbox_inches=\"tight\")\n            plt.close(fig)\n            yield buf.getvalue()\n\napp = App(app_ui, server)", "type": "text"}, {"name": "requirements.txt", "content": "pandas\nmatplotlib\nseaborn\nbiopython", "type": "text"}]